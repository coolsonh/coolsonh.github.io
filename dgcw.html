<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>YouTube Multi-Channel Viewer — List View</title>


<style>
  :root {
    --bg: #0f1115;
    --card: #151925;
    --muted: #94a3b8;
    --text: #e5e7eb;
    --accent: #60a5fa;
    --accent-2: #a78bfa;
    --ok: #22c55e;
    --warn: #f59e0b;
    --danger: #ef4444;
    --border: #243044;
    --row: #11141d;
    --rowHover: #161b26;
  }

  html, body { margin:0; font-family: system-ui,-apple-system,Segoe UI,Roboto,sans-serif; background:var(--bg); color:var(--text); }
  
  /* Header */
  header { background:#0b0d12; border-bottom:1px solid var(--border); padding:16px 20px; position:sticky; top:0; z-index:10; }
  header .title { font-size:18px; font-weight:700; display:flex; align-items:center; justify-content:space-between; }
  header .subtitle { color:var(--muted); font-size:12px; margin-top:4px; }
  a { color:#93c5fd; }
  
  /* Layout */
  .container { padding:16px 12px 60px; max-width:900px; margin:0 auto; }
  .panel { background:var(--card); border:1px solid var(--border); border-radius:12px; padding:16px; margin-bottom:16px; }
  .panel h3 { margin:0 0 12px; font-size:16px; }
  
  /* Inputs & Buttons */
  .flex { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
  textarea, input[type=text], select {
    width:100%; background:#0b0d12; border:1px solid var(--border); color:var(--text);
    border-radius:8px; padding:12px; outline:none; font-size:16px; /* 16px prevents iOS zoom */
    box-sizing: border-box;
  }
  button, .btn {
    background:#1f2a44; color:var(--text); border:1px solid var(--border); border-radius:8px;
    padding:8px 14px; font-weight:600; cursor:pointer; font-size:14px; user-select:none;
  }
  button:hover { background:#22304f; }
  .btn-danger { background:rgba(239,68,68,.1); border-color:var(--danger); color:#fecaca; }
  .btn-ok { background:rgba(34,197,94,.1); border-color:var(--ok); color:#dcfce7; }
  .muted { color:var(--muted); } .small { font-size:12px; }

  /* Chips */
  .chips { display:flex; gap:8px; flex-wrap:wrap; }
  .chip { background:#0b0d12; border:1px solid var(--border); padding:6px 10px; border-radius:999px; display:inline-flex; align-items:center; gap:8px; font-size:13px; }
  .chip .x { cursor:pointer; color:#fca5a5; font-weight:700; padding:2px; }

  /* Tabs */
  .tabs { display:flex; gap:8px; border-bottom:1px solid var(--border); margin-top:12px; overflow-x:auto; padding-bottom:2px; }
  .tab { padding:10px 16px; cursor:pointer; border-radius:8px 8px 0 0; background:#0b0d12; color:var(--muted); white-space:nowrap; font-size:14px; }
  .tab.active { background:var(--card); color:#e5e7eb; border:1px solid var(--border); border-bottom:none; font-weight:600; }
  .tabpane { display:none; padding-top:16px; }
  .tabpane.active { display:block; }

  /* List/Table View */
  table { width:100%; border-collapse:collapse; background:transparent; border:none; }
  thead { display:none; /* Hide headers for list view */ }
  
  tbody tr.video-row { 
    border:1px solid var(--border); 
    background:var(--row); 
    display:block; 
    margin-bottom:12px; 
    border-radius:10px;
    transition: background 0.2s;
  }
  tbody tr.video-row:hover { background:var(--rowHover); border-color:#374151; }
  
  td { padding:14px; display:block; width:100%; box-sizing:border-box; }
  
  /* Video Card Styles */
  .v-title { 
    font-size:16px; font-weight:600; line-height:1.4; margin-bottom:10px; color:#f3f4f6; 
    display:block;
  }
  .v-meta { 
    display:flex; align-items:center; gap:12px; flex-wrap:wrap; 
    font-size:13px; color:var(--muted); 
  }
  .v-meta-item { display:flex; align-items:center; gap:6px; }
  .bullet { color:#374151; }

  .badge {
    display:inline-flex; gap:4px; align-items:center; border:1px solid #14532d; color:#bbf7d0;
    background:rgba(34,197,94,.1); padding:2px 8px; border-radius:4px; font-size:11px; font-weight:600;
    vertical-align:middle; margin-left:6px;
  }
  .badge.inprogress { border-color:#1e3a8a; color:#bfdbfe; background:rgba(96,165,250,.1); }

  .pbar { height:6px; width:80px; background:#000; border:1px solid #333; border-radius:999px; overflow:hidden; display:inline-block; }
  .pfill { height:100%; background:var(--accent); width:0%; transition:width .2s; }
  .pfill.done { background:var(--ok); }
  
  .actions { margin-left:auto; display:flex; gap:8px; }

  /* Player */
  .player-row td { padding:0; background:#000; border-radius:0 0 10px 10px; overflow:hidden; }
  .player-row { border:1px solid var(--border); border-top:none; margin-top:-13px; margin-bottom:12px; display:block; }
  .player-box { aspect-ratio:16/9; width:100%; }

  /* Mobile Tweaks */
  @media (max-width: 600px) {
    .v-meta { align-items:flex-start; gap:8px; }
    .actions { width:100%; margin-top:8px; justify-content:flex-start; }
    .actions button { flex:1; justify-content:center; }
    .pbar { width:60px; }
    #searchBox { margin-bottom:8px; }
    .flex > * { width:100%; } /* Stack filters on very small screens */
    .flex > label { width:auto; } /* except checkboxes */
  }
</style>
</head>
<body>
<header>
  <div class="title">
    <span>Multi‑Channel Viewer</span>
    <button id="settingsBtn" class="small">Settings</button>
  </div>
</header>

<div id="settings" class="container" style="display:none;">

  <div class="panel">
    <h3>Add Channels</h3>
    <div class="muted small" style="margin-bottom:8px;">
      Paste one per line. Get IDs at
      <a href="https://ytpeek.com/tools/channel-id-finder" target="_blank">ytpeek.com</a>
    </div>
    <textarea id="channelsInput" rows="3" placeholder="UC_x5XG1OV2P6uZZ5FSM9Ttw"></textarea>
    <div class="flex" style="margin-top:12px;">
      <button id="addChannelsBtn" class="btn-ok">Add Channels</button>
      <button id="refreshBtn">Refresh Feeds</button>
      <button id="clearBtn" class="btn-danger">Reset App</button>
    </div>
    <div id="status" class="muted small" style="margin-top:8px;"></div>

    <div style="margin-top:16px;">
      <h3>Your Channels</h3>
      <div id="channelsList" class="chips"></div>
    </div>
  </div>

  <div class="panel">
    <h3>Backup & Settings</h3>
    <div class="flex">
      <button id="exportBtn">Export Data</button>
      <label class="btn" for="importFile" style="cursor:pointer; text-align:center;">Import Data</label>
      <input id="importFile" type="file" accept="application/json" style="display:none;">
    </div>
    <div style="margin-top:12px; border-top:1px solid var(--border); padding-top:12px;">
        <label class="flex" style="gap:8px; margin-bottom:8px;">
            <input id="useProxy" type="checkbox"> <span>Use CORS Proxy (fix feed errors)</span>
        </label>
        <select id="proxyUrl">
            <option value="https://api.allorigins.win/raw?url=">AllOrigins (raw)</option>
            <option value="https://r.jina.ai/">r.jina.ai</option>
            <option value="https://cors.isomorphic-git.org/">isomorphic-git CORS</option>
        </select>
        <div class="small" style="margin-top:8px;">
            Auto‑mark watched at: <span id="thVal">90%</span>
            <input id="threshold" type="range" min="50" max="100" value="90" style="width:100%;">
        </div>
    </div>
  </div>
  </div>

  <div class="container">
    <div class="panel" style="padding:12px;">
        <div class="flex" style="gap:8px;">
            <input id="searchBox" type="text" placeholder="Search title or channel…">
            <select id="channelFilter">
            <option value="">All channels</option>
            </select>
        </div>
        <div class="flex" style="justify-content:space-between; margin-top:12px;">
             <div id="summary" class="muted small" style="align-self:center;">Loading...</div>
             <label class="flex small" style="gap:6px; width:auto;">
                <input id="hideShorts" type="checkbox"> Hide Shorts
             </label>
        </div>
    </div>

    <div class="tabs">
      <div class="tab active" data-tab="unwatched">Unwatched</div>
      <div class="tab" data-tab="all">All Videos</div>
      <div class="tab" data-tab="watched">History</div>
    </div>

    <div id="tab-unwatched" class="tabpane active">
      <table><tbody id="tbody-unwatched"></tbody></table>
    </div>

    <div id="tab-all" class="tabpane">
      <table><tbody id="tbody-all"></tbody></table>
    </div>

    <div id="tab-watched" class="tabpane">
      <div class="muted small" style="margin-bottom:8px; text-align:center;">
        Videos appear here after you finish them.
      </div>
      <table><tbody id="tbody-watched"></tbody></table>
    </div>
  </div>


<script>
/** =========================
 * State
 * ========================= */
const STATE_KEY = 'ytMultiState_v5_mobile';
const defaultState = {
  channels: [],
  videos: {},
  settings: {
    useProxy: true,
    proxyUrl: 'https://api.allorigins.win/raw?url=',
    threshold: 0.9,
    hideShorts: true
  },
  lastUpdated: 0
};
let state = loadState();

/** Load & Save */
function loadState(){
  try {
    const s = localStorage.getItem(STATE_KEY);
    if (!s) return JSON.parse(JSON.stringify(defaultState));
    const parsed = JSON.parse(s);
    parsed.settings = Object.assign({}, defaultState.settings, parsed.settings||{});
    parsed.channels = Array.isArray(parsed.channels) ? parsed.channels : [];
    parsed.videos = parsed.videos || {};
    return parsed;
  } catch { return JSON.parse(JSON.stringify(defaultState)); }
}
function saveState(){ state.lastUpdated = Date.now(); localStorage.setItem(STATE_KEY, JSON.stringify(state)); }

/** Utils */
const sleep = ms => new Promise(r=>setTimeout(r,ms));
function fmtDate(iso){ const d=new Date(iso); return isNaN(d)?'':d.toLocaleDateString(); }
function timeAgo(iso){
  const d = new Date(iso), now = new Date(), s = Math.floor((now-d)/1000);
  if (s<60) return `${s}s ago`; const m=Math.floor(s/60); if (m<60) return `${m}m ago`;
  const h=Math.floor(m/60); if (h<24) return `${h}h ago`; const days=Math.floor(h/24);
  if (days<30) return `${days}d ago`; const mo=Math.floor(days/30); if (mo<12) return `${mo}mo ago`;
  const y=Math.floor(mo/12); return `${y}y ago`;
}
function escapeHtml(s){return (s||'').replace(/[&<>"']/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));}

function extractChannelId(input){
  input = input.trim(); if (!input) return null;
  const m=input.match(/youtube\.com\/channel\/(UC[0-9A-Za-z_-]{20,})/i); if (m) return m[1];
  const m2=input.match(/^(UC[0-9A-Za-z_-]{20,})$/); if (m2) return m2[1];
  return null;
}

/** Feed Logic */
function feedUrlForChannel(channelId){ return `https://www.youtube.com/feeds/videos.xml?channel_id=${encodeURIComponent(channelId)}`; }

async function fetchTextWithFallback(url){
  const useProxy = state.settings.useProxy;
  const proxyBase = state.settings.proxyUrl || '';
  const candidates = [];
  if (!useProxy) candidates.push(url);
  const encoded = encodeURIComponent(url);
  if (proxyBase.includes('allorigins')) candidates.push(`${proxyBase}${encoded}`);
  else candidates.push(`${proxyBase}${url}`);
  candidates.push(`https://r.jina.ai/${url}`, `https://cors.isomorphic-git.org/${url}`);
  
  let lastErr=null; const tried=new Set();
  for (const c of candidates){
    if (tried.has(c)) continue; tried.add(c);
    try { const res=await fetch(c,{mode:'cors',credentials:'omit'}); if(!res.ok){lastErr=new Error('HTTP '+res.status);continue;}
      const txt=await res.text(); if (txt) return txt;
    } catch(e){ lastErr=e; }
  }
  throw lastErr||new Error('Fetch failed');
}

function parseYouTubeFeed(xmlText){
  const doc = new DOMParser().parseFromString(xmlText,'application/xml');
  if (doc.querySelector('parsererror')) throw new Error('Invalid XML');
  const entries = [...doc.getElementsByTagName('entry')];
  return entries.map(entry=>{
    const get = sel => (entry.querySelector(sel)||entry.getElementsByTagName(sel)[0])?.textContent?.trim()||'';
    const videoId = get('yt\\:videoId') || get('videoId') || (get('id').startsWith('yt:video:') ? get('id').replace('yt:video:','') : '');
    const channelId = get('yt\\:channelId') || get('channelId') || '';
    const title = get('title');
    const author = entry.querySelector('author > name')?.textContent?.trim() || '';
    const linkEl = entry.querySelector('link[rel="alternate"]');
    const link = linkEl ? linkEl.getAttribute('href') : (videoId ? `https://www.youtube.com/watch?v=${videoId}` : '');
    const published = get('published') || get('updated') || '';

    let durationSec = 0;
    const ytDur = entry.querySelector('yt\\:duration');
    if (ytDur && ytDur.getAttribute) {
      const s = parseInt(ytDur.getAttribute('seconds')||'0', 10);
      if (!isNaN(s) && s>0) durationSec = s;
    }
    return { videoId, channelId, title, channelTitle: author, link, publishedAt: published, durationSec };
  }).filter(e=>e.videoId);
}

/** Player Logic */
let YT_API_READY=false, pendingPlayerInits=[], players={}; 

function loadYouTubeAPIOnce(){
  if (window._ytApiInjected) return;
  window._ytApiInjected=true;
  const tag=document.createElement('script'); tag.src="https://www.youtube.com/iframe_api";
  document.body.appendChild(tag);
}
window.onYouTubeIframeAPIReady = function(){
  YT_API_READY=true; pendingPlayerInits.forEach(args=>createPlayer(args)); pendingPlayerInits=[];
};

function ensurePlayer(videoId, container, onReady){
  if (YT_API_READY && window.YT && YT.Player) createPlayer({videoId, container, onReady});
  else { loadYouTubeAPIOnce(); pendingPlayerInits.push({videoId, container, onReady}); }
}

function createPlayer({videoId, container, onReady}){
  if (players[videoId]?.player?.destroy) { try{ players[videoId].player.destroy(); }catch{} }
  const origin = (location.origin && location.origin.startsWith('http')) ? location.origin : undefined;
  const player = new YT.Player(container, {
    width:'100%', videoId,
    playerVars:{ enablejsapi:1, rel:0, modestbranding:1, playsinline:1, autoplay:1, origin },
    events:{
      onReady:(e)=>{ 
        const v=state.videos[videoId];
        if (v?.lastTime>0){ try{ e.target.seekTo(v.lastTime,true); }catch{} }
        try { e.target.playVideo(); } catch {}
        onReady && onReady(e);
      },
      onStateChange:(e)=>handleStateChange(videoId,e)
    }
  });
  players[videoId] = { player, timer:null, lastSave:0 };
}

function handleStateChange(videoId, e){
  const P = YT.PlayerState; const rec = players[videoId]; if (!rec) return;
  const start = ()=>{ if (rec.timer) return; rec.timer=setInterval(()=>updateProgress(videoId),1000); };
  const stop  = ()=>{ if (rec.timer) clearInterval(rec.timer); rec.timer=null; };
  switch(e.data){
    case P.PLAYING: start(); break;
    case P.PAUSED: case P.BUFFERING: case P.CUED: stop(); updateProgress(videoId); break;
    case P.ENDED: stop(); setWatched(videoId, 1.0); collapsePlayerFor(videoId); break;
  }
}

function updateProgress(videoId){
  const rec = players[videoId]; if (!rec?.player?.getDuration) return;
  const dur = rec.player.getDuration()||0;
  const cur = rec.player.getCurrentTime ? rec.player.getCurrentTime() : 0;
  if (!dur || dur<1) return;
  const progress = Math.min(1, cur/dur);
  const v = state.videos[videoId] || {};
  v.progress=progress; v.lastTime=cur; v.duration=dur; state.videos[videoId]=v;
  const threshold = state.settings.threshold||0.9;
  if (!v.watched && progress>=threshold) v.watched=true;
  const now=Date.now(); if (!rec.lastSave || now-rec.lastSave>5000){ saveState(); rec.lastSave=now; }
  updateRowState(videoId);
}

function collapsePlayerFor(videoId){
  $(`tr.player-row[data-for="${videoId}"]`).each((_,tr)=>{
    const $pr=$(tr); 
    if ($pr.is(':visible')) {
        $pr.hide();
        // find previous video row to reset button
        const $base=$(`tr.video-row[data-id="${videoId}"]`);
        $base.find('.playbtn').text('Play');
        try { players[videoId]?.player?.pauseVideo(); } catch {}
    }
  });
}

function setWatched(videoId, progress=1){
  const v=state.videos[videoId]||{}; v.watched=true; v.progress=Math.max(progress, v.progress||0);
  state.videos[videoId]=v; saveState(); updateRowState(videoId); renderTablesAndSummary();
}
function setUnwatched(videoId){
  const v=state.videos[videoId]||{}; v.watched=false;
  state.videos[videoId]=v; saveState(); updateRowState(videoId); renderTablesAndSummary();
}

/** Shorts detection */
function isShortFromFields({title='', link='', durationSec=0, duration=0}){
  const dur = Math.floor(durationSec || duration || 0);
  if (dur > 0) return dur <= 60;
  const t = (title||'').toLowerCase();
  if (t.includes('#shorts')) return true;
  if ((link||'').includes('/shorts/')) return true;
  return false;
}

/** UI Rendering */
let latestFeedItems=[];

async function refreshFeedsUI(){
  $('#status').text('Refreshing feeds…');
  try {
    latestFeedItems = await loadAllFeeds();
    renderTablesAndSummary();
    $('#status').text(`Updated: ${new Date().toLocaleTimeString()}`);
  } catch(e){
    console.error(e);
    $('#status').html(`<span style="color:var(--danger)">Error: ${escapeHtml(e.message||'Unknown')}</span>`);
  }
}

async function loadAllFeeds(){
  const items=[]; const channels = state.channels.map(c=>c.id);
  for (const id of channels){
    try {
      const xml = await fetchTextWithFallback(feedUrlForChannel(id));
      const entries = parseYouTubeFeed(xml);
      const title = entries[0]?.channelTitle || '';
      if (title){
        const c = state.channels.find(x=>x.id===id);
        if (c && !c.title){ c.title=title; saveState(); }
      }
      items.push(...entries);
    } catch(e){ console.warn('Channel failed', id, e); }
    await sleep(150);
  }
  items.sort((a,b)=> new Date(b.publishedAt)-new Date(a.publishedAt));
  const seen=new Set(), out=[];
  for (const it of items){ if (seen.has(it.videoId)) continue; seen.add(it.videoId); out.push(it); }
  return out;
}

function renderTablesAndSummary(){
  renderTable('#tbody-unwatched', i => !state.videos[i.videoId]?.watched);
  renderTable('#tbody-all', i => true);
  renderTable('#tbody-watched', i => state.videos[i.videoId]?.watched, true);
  
  const all = filteredItems(latestFeedItems).length;
  const unw = filteredItems(latestFeedItems).filter(it => !state.videos[it.videoId]?.watched).length;
  $('#summary').text(`${unw} unwatched · ${all} total`);
}

function filteredItems(sourceItems){
  const q = ($('#searchBox').val()||'').toLowerCase();
  const cf = $('#channelFilter').val()||'';
  const hideShorts = !!$('#hideShorts').prop('checked');
  
  // For watched tab logic, we might need a larger pool if they aren't in feed anymore
  // But for now we just filter feed items + known watched items if we wanted
  // The logic below assumes we only show what's in the RSS feed + history of those.
  // To show OLD watched videos not in feed, we'd need to merge state.videos keys.
  
  return sourceItems.filter(it=>{
    if (cf && it.channelId !== cf) return false;
    if (hideShorts && isShortFromFields(it)) return false;
    if (!q) return true;
    const hay = `${it.title} ${it.channelTitle}`.toLowerCase();
    return hay.includes(q);
  });
}

function renderTable(tbodyId, filterFn, isWatchedTab=false){
  let items;
  if (isWatchedTab) {
    // For watched tab, we pull from state to ensure we see history even if RSS fell off
    // Simplified: Mixing RSS items and local state items
    const q = ($('#searchBox').val()||'').toLowerCase();
    const cf = $('#channelFilter').val()||'';
    const hideShorts = !!$('#hideShorts').prop('checked');
    items = Object.entries(state.videos)
      .filter(([id, v]) => v.watched)
      .map(([id,v]) => ({ videoId:id, ...v }))
      .filter(v => {
        if (cf && v.channelId !== cf) return false;
        if (hideShorts && isShortFromFields(v)) return false;
        if (!q) return true;
        return `${v.title} ${v.channelTitle}`.toLowerCase().includes(q);
      })
      .sort((a,b)=> (new Date(b.publishedAt||0)) - (new Date(a.publishedAt||0)));
  } else {
    items = filteredItems(latestFeedItems).filter(filterFn);
  }

  const $tb = $(tbodyId).empty();
  items.forEach(it => {
    ensureVideoStatePrimed(it);
    const v = state.videos[it.videoId]; 
    const pct = Math.round((v.progress||0)*100);
    const $row = buildVideoRow(it.videoId, it.title, it.channelTitle||it.channelId, it.publishedAt, pct, v.watched);
    attachRowHandlers($row, it.videoId);
    $tb.append($row);
  });
}

function ensureVideoStatePrimed(it){
  const existing = state.videos[it.videoId];
  if (!existing){
    state.videos[it.videoId] = {
      watched:false, progress:0, lastTime:0, duration:it.durationSec||0,
      title: it.title, channelId: it.channelId, channelTitle: it.channelTitle,
      publishedAt: it.publishedAt, link: it.link
    };
  } else {
    // Update metadata if found in feed again
    existing.title = it.title || existing.title;
    existing.channelTitle = it.channelTitle || existing.channelTitle;
    existing.publishedAt = it.publishedAt || existing.publishedAt;
  }
}

/** New Layout Generator */
function buildVideoRow(videoId, title, channel, publishedAt, pct, watched){
    const ago = publishedAt ? timeAgo(publishedAt) : '';
    const badgeHtml = watched 
        ? `<span class="badge">Watched ✓</span>` 
        : (pct > 0 ? `<span class="badge inprogress">In Progress</span>` : '');

    return $(`
    <tr class="video-row" data-id="${videoId}">
      <td>
        <div class="v-title">${escapeHtml(title)} ${badgeHtml}</div>
        <div class="v-meta">
            <span class="v-meta-item" style="color:var(--accent-2); font-weight:600;">${escapeHtml(channel)}</span>
            <span class="bullet">•</span>
            <span class="v-meta-item" title="${fmtDate(publishedAt)}">${ago}</span>
            <span class="bullet">•</span>
            <div class="pbar"><div class="pfill ${watched?'done':''}" style="width:${pct}%;"></div></div>
            
            <div class="actions">
                <button class="playbtn">${watched ? 'Replay' : 'Play'}</button>
                <button class="markbtn" style="${watched?'display:none;':''}">Mark Done</button>
                <button class="unmarkbtn" style="${watched?'':'display:none;'}">Unwatch</button>
                <button class="openbtn" title="Open on YouTube">↗</button>
            </div>
        </div>
      </td>
    </tr>
    `);
}

function togglePlayerRow(videoId, baseRow, open){
  const $base = $(baseRow);
  let $pr = $base.next();
  // Check if next row is actually the player row for this video
  const isPlayer = $pr.hasClass('player-row') && $pr.attr('data-for') === videoId;

  if (open){
    if (!isPlayer){
      $pr = $(`
        <tr class="player-row" data-for="${videoId}">
          <td>
            <div class="player-box">
              <div id="player-${videoId}" style="width:100%; height:100%;"></div>
            </div>
          </td>
        </tr>
      `);
      $base.after($pr);
      const cont = $pr.find(`#player-${videoId}`)[0];
      ensurePlayer(videoId, cont, ()=>{});
    } else {
      $pr.show();
      try { players[videoId]?.player?.playVideo(); } catch {}
    }
    $base.find('.playbtn').text('Hide');
  } else {
    if (isPlayer){
      $pr.hide();
      try { players[videoId]?.player?.pauseVideo(); } catch {}
    }
    $base.find('.playbtn').text('Play');
  }
}

function attachRowHandlers($row, videoId){
  const playToggle = ()=>{
    const $next = $row.next();
    const isVisible = $next.hasClass('player-row') && $next.is(':visible') && $next.attr('data-for') === videoId;
    togglePlayerRow(videoId, $row[0], !isVisible);
  };
  
  // Make title clickable too for ease
  $row.find('.v-title').css('cursor','pointer').on('click', playToggle);
  $row.find('.playbtn').on('click', playToggle);

  $row.find('.markbtn').on('click', ()=> setWatched(videoId, 1));
  $row.find('.unmarkbtn').on('click', ()=> setUnwatched(videoId));
  $row.find('.openbtn').on('click', ()=>{
    const link = state.videos[videoId]?.link || `https://www.youtube.com/watch?v=${videoId}`;
    window.open(link, '_blank', 'noopener');
  });
}

function updateRowState(videoId){
  const v = state.videos[videoId] || {};
  const pct = Math.round((v.progress||0)*100);
  const watched = !!v.watched;

  $(`tr.video-row[data-id="${videoId}"]`).each((_, el)=>{
    const $row = $(el);
    const $fill = $row.find('.pfill'); 
    $fill.css('width', pct+'%').toggleClass('done', watched);
    
    // Toggle badge and buttons
    const $title = $row.find('.v-title');
    $title.find('.badge').remove();
    if(watched) $title.append(`<span class="badge">Watched ✓</span>`);
    else if(pct>0) $title.append(`<span class="badge inprogress">In Progress</span>`);

    if(watched){
        $row.find('.markbtn').hide(); 
        $row.find('.unmarkbtn').show();
        $row.find('.playbtn').text('Replay');
    } else {
        $row.find('.markbtn').show(); 
        $row.find('.unmarkbtn').hide();
    }
  });
}

/** Settings & Events */
$('#settingsBtn').on('click', () => $('#settings').toggle());

$('#addChannelsBtn').on('click', ()=>{
  const raw=$('#channelsInput').val()||'';
  const lines=raw.split(/\r?\n/).map(x=>x.trim()).filter(Boolean);
  let added=0;
  lines.forEach(line=>{
    const id=extractChannelId(line);
    if (!id || state.channels.some(c=>c.id===id)) return;
    state.channels.push({id, title:''}); added++;
  });
  saveState(); $('#channelsInput').val('');
  renderChannelsList(); 
  if (added>0) refreshFeedsUI();
  // Hide settings if we successfully added stuff and it was the first time
  if (state.channels.length > 0 && added > 0) $('#settings').hide();
});

$('#refreshBtn').on('click', refreshFeedsUI);

$('#clearBtn').on('click', ()=>{
  if (!confirm('This clears ALL channels and watch history. Continue?')) return;
  state = JSON.parse(JSON.stringify(defaultState)); saveState();
  location.reload(); 
});

$('#exportBtn').on('click', ()=>{
  const blob=new Blob([JSON.stringify(state,null,2)], {type:'application/json'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob);
  a.download=`yt-multi-${new Date().toISOString().split('T')[0]}.json`;
  document.body.appendChild(a); a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),1000); a.remove();
});

$('#importFile').on('change', (e)=>{
  const file=e.target.files[0]; if (!file) return;
  const r=new FileReader();
  r.onload=()=>{
    try{
      const data=JSON.parse(r.result);
      if (!data || !data.channels) throw new Error('Invalid file');
      state=Object.assign({}, defaultState, data);
      saveState(); location.reload();
    } catch(err){ alert('Import failed'); }
  };
  r.readAsText(file);
});

/* Tabs */
$('.tab').on('click', function(){
  $('.tab').removeClass('active'); $(this).addClass('active');
  const tab=$(this).data('tab'); $('.tabpane').removeClass('active'); $(`#tab-${tab}`).addClass('active');
});

/* Filters */
$('#searchBox').on('input', renderTablesAndSummary);
$('#channelFilter').on('change', renderTablesAndSummary);
$('#hideShorts').on('change', function(){
  state.settings.hideShorts = !!this.checked; saveState(); renderTablesAndSummary();
});
$('#useProxy').on('change', function(){ state.settings.useProxy=this.checked; saveState(); });
$('#proxyUrl').on('change', function(){ state.settings.proxyUrl=this.value; saveState(); });
$('#threshold').on('input', function(){ $('#thVal').text(`${Number(this.value)}%`); });
$('#threshold').on('change', function(){
  state.settings.threshold=Math.max(0.5, Math.min(1.0, this.value/100)); saveState();
});

function renderChannelsList(){
  const $sel = $('#channelFilter').empty().append('<option value="">All channels</option>');
  const $wrap = $('#channelsList').empty();
  
  state.channels.forEach(c=>{
    const label = c.title || c.id;
    $sel.append(`<option value="${escapeHtml(c.id)}">${escapeHtml(label)}</option>`);
    
    const $chip = $(`<div class="chip"><span>${escapeHtml(label)}</span><span class="x">×</span></div>`);
    $chip.find('.x').on('click', ()=>{
      if(confirm('Remove channel?')){
        state.channels = state.channels.filter(x=>x.id!==c.id);
        saveState(); renderChannelsList(); refreshFeedsUI();
      }
    });
    $wrap.append($chip);
  });
}

/** Startup */
$('#useProxy').prop('checked', !!state.settings.useProxy);
$('#proxyUrl').val(state.settings.proxyUrl || 'https://api.allorigins.win/raw?url=');
$('#threshold').val((state.settings.threshold||0.9)*100);
$('#hideShorts').prop('checked', !!state.settings.hideShorts);

renderChannelsList();

// Show settings automatically if no channels exist
if (state.channels.length === 0) {
    $('#settings').show();
} else {
    $('#settings').hide();
    refreshFeedsUI();
}
</script>
</body>
</html>
